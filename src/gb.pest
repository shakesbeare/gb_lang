// Prepatory    ------------------------
WHITESPACE = _{ " " | "\n" | "\t" } // ' ', '\n', and '\t' will be ignored during lexing
COMMENT = _{
      "//" ~ (!"\n" ~ ANY)* // single line comment
    | "/*" ~ (ANY)* ~ "*/"  // multi line comment 
}

// Nonterminals ------------------------
program = _{ 
      SOI ~  declList ~ EOI 
    | SOI ~ "" ~ EOI
}
declList = _{ decl ~ declListPrime } 
declListPrime = _{ declList | "" }
decl = _{ varDecl | funDecl } // Gb programs may only have variable or function declarations at the top level
varDecl = { declarationKeyword ~ varDeclIdentifiers ~ varDeclAssignment }
varDeclIdentifiers = { varDeclParen | identifier }
    varDeclParen = {
          lParen ~ varDeclMultiple ~ rParen 
        | lParen ~ identifier ~ rParen
} // `let x: int = 5;` or `let (x, y): int = 5;` 

    varDeclMultiple = { identifier ~ varDeclMultiPrime }
    varDeclMultiPrime = { comma ~ varDeclMultiple | "" }

varDeclAssignment = {
      equal ~ expStmt 
    | typeHint ~ equal ~ expStmt 
} // `let x = 5;` or `let x: int = 5`
typeHint = { colon ~ identifier } // e.g. `: int`

funDecl = { fnReturnType ~ identifier ~ lParen ~ params ~ rParen ~ stmt } // e.g. `void myFunc()...` or `MyType myFunc()...`
fnReturnType = { "void" | identifier }
params = { identifier ~ identifier ~ paramsPrime} // e.g. (int x, int y)
paramsPrime = { params | "" }

stmt = {
      expStmt
    | compoundStmt
    | selectStmt
    | iterStmt
    | returnStmt
    | breakStmt
}
expStmt = { exp ~ semicolon}
compoundStmt = { 
      lBrace ~ compoundStmt ~ rBrace
    | lBrace ~ declList ~ rBrace
    | lBrace ~ stmtList ~ rBrace 
    | lBrace ~ "" ~ rBrace
}
    stmtList = { stmt ~ stmtListPrime }
    stmtListPrime = { stmtList | "" }
selectStmt = { ifKeyword ~ simpleExp ~ compoundStmt ~ (elseKeyword ~ compoundStmt)? }
iterStmt = { whileKeyword ~ simpleExp ~ compoundStmt | forKeyword ~ identifier ~ inKeyword ~ identifier ~ compoundStmt }
returnStmt = { returnKeyword ~ semicolon | returnKeyword ~ exp ~ semicolon }
breakStmt = { breakKeyword ~ semicolon }

exp = { 
      mutable ~ equal ~ exp
    | mutable ~ plus ~ equal ~ exp
    | mutable ~ minus ~ equal ~ exp
    | mutable ~ multiply ~ equal ~ exp
    | mutable ~ divide ~ equal ~ exp
    | mutable ~ plus ~ plus
    | mutable ~ minus ~ minus
    | simpleExp
}

simpleExp = { andExp ~ orKeyword ~ simpleExp | andExp }
andExp = { unaryRelExp ~ andKeyword ~ andExp | unaryRelExp }
unaryRelExp = { notKeyword ~ unaryRelExp | relExp }
relExp = { sumExp ~ relOp ~ sumExp | sumExp } 
sumExp = { mulExp ~ sumOp ~ sumExp | mulExp }
    sumOp = { plus | minus }
mulExp = { unaryExp ~ mulOp ~ mulExp | unaryExp }
    mulOp = { multiply | divide | modulo }
unaryExp = {  unaryOp ~ unaryExp | factor }
    unaryOp = { minus ~ multiply ~ question }
factor = { mutable | immutable }
mutable = { identifier }
immutable = { lParen ~ exp ~ rParen | call | constant }
call = { identifier ~ lParen ~ args ~ rParen }
args = { argList | "" }
argList = { exp ~ (comma ~ argList)* }
constant = { number | string }
number = { decimal | integer }


// Terminals    ------------------------:w

// keywords 
declarationKeyword = @{ "let" | "const" }
ifKeyword = @{ "if" }
elseKeyword = @{ "else" }
whileKeyword = @{ "while" }
forKeyword = @{ "for" }
inKeyword = @{ "in" }
returnKeyword = @{ "return" }
breakKeyword = @{ "break" }
trueKeyword = @{ "true" }
falseKeyword = @{ "false" }


// logical operators
andKeyword = @{ "&&" }
orKeyword = @{ "||" }
notKeyword = @{ "!" }
relOp = @{ 
      "<="
    | "<"
    | ">"
    | ">="
    | "=="
    | "!="
}

// mathematical operators
plus = @{ "+" }
minus = @{ "-" }
multiply = @{ "*" }
divide = @{ "/" }
modulo = @{ ""}


// tokens
equal = @{ "=" }
colon = @{ ":" }
semicolon = @{ ";" }
comma = @{ "," }
question = @{ "?" }
lParen = @{ "(" }
rParen = @{ ")" }
lBrace = @{ "{" }
rBrace = @{ "}" }


decimal = @{ ASCII_DIGIT ~ (ASCII_DIGIT)* ~ "." ~ (ASCII_DIGIT)* }
integer = @{ (ASCII_DIGIT)+ }
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
string = @{ 
      "\"" ~ (!"\"" ~ ANY)* ~ "\""
    | "'" ~ (!"'" ~ ANY)* ~ "'" 
}